package http

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/go-playground/validator/v10"
	"github.com/labstack/echo/v4"
	"github.com/rendyfutsuy/base-go/constants"
	"github.com/rendyfutsuy/base-go/helpers/middleware"
	_reqContext "github.com/rendyfutsuy/base-go/helpers/middleware/request"
	"github.com/rendyfutsuy/base-go/helpers/request"
	"github.com/rendyfutsuy/base-go/helpers/response"
	"github.com/rendyfutsuy/base-go/models"
	"github.com/rendyfutsuy/base-go/modules/expedition"
	"github.com/rendyfutsuy/base-go/modules/expedition/dto"
)

type ResponseError struct {
	Message string `json:"message"`
}

type Response struct {
	Message string `json:"message"`
}

type ExpeditionHandler struct {
	Usecase              expedition.Usecase
	validator            *validator.Validate
	mwPageRequest        _reqContext.IMiddlewarePageRequest
	middlewareAuth       middleware.IMiddlewareAuth
	middlewarePermission middleware.IMiddlewarePermission
}

func NewExpeditionHandler(e *echo.Echo, uc expedition.Usecase, mwP _reqContext.IMiddlewarePageRequest, auth middleware.IMiddlewareAuth, middlewarePermission middleware.IMiddlewarePermission) {
	h := &ExpeditionHandler{Usecase: uc, validator: validator.New(), mwPageRequest: mwP, middlewareAuth: auth, middlewarePermission: middlewarePermission}

	r := e.Group("/v1/expedition")
	r.Use(h.middlewareAuth.AuthorizationCheck)

	// Permissions
	// View:   expedition.view
	// Create: expedition.create
	// Update: expedition.update
	// Delete: expedition.delete
	// Export: expedition.export
	permissionToView := []string{"expedition.view"}
	permissionToCreate := []string{"expedition.create"}
	permissionToUpdate := []string{"expedition.update"}
	permissionToDelete := []string{"expedition.delete"}
	permissionToExport := []string{"expedition.export"}

	// Index with pagination + search
	r.GET("", h.GetIndex, middleware.RequireActivatedUser, h.mwPageRequest.PageRequestCtx, h.middlewarePermission.PermissionValidation(permissionToView))

	// Export (no pagination, same filters) - must be before /:id to avoid route conflict
	r.GET("/export", h.Export, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToExport))

	// Get by ID (detail) - must be after /export to avoid route conflict
	r.GET("/:id", h.GetByID, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToView))

	// Create
	r.POST("", h.Create, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToCreate))

	// Update
	r.PUT("/:id", h.Update, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToUpdate))

	// Delete
	r.DELETE("/:id", h.Delete, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToDelete))
}

// Create godoc
// @Summary		Create a new expedition
// @Description	Create a new expedition with provided information. Accepts JSON body with telp_numbers (array of objects where area_code optional and phone_number required, contoh: [{&quot;area_code&quot;:&quot;022&quot;,&quot;phone_number&quot;:&quot;1112223355&quot;}, {&quot;area_code&quot;:&quot;022&quot;,&quot;phone_number&quot;:&quot;1112223366&quot;}]) and phone_numbers arrays. First index of telp_numbers array will automatically become primary telp, and first index of phone_numbers array will automatically become primary hp. Phone numbers can be duplicated across different expeditions. Expedition code is automatically generated by the system. Requires 'api.master-data.expedition.create' permission.
// @Tags			Expedition
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			request	body		dto.ReqCreateExpedition	true	"Expedition creation data. Fields: expedition_name (required), address (max 255 chars), telp_numbers (array, first index becomes primary telp), phone_numbers (array, first index becomes primary hp), notes (optional)"
// @Success		200		{object}	response.NonPaginationResponse{data=dto.RespExpedition}	"Successfully created expedition with full details including contacts"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - validation error or duplicate phone number/expedition name"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Router			/v1/expedition [post]
func (h *ExpeditionHandler) Create(c echo.Context) error {
	req := new(dto.ReqCreateExpedition)
	if err := c.Bind(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	if err := bindExpeditionTelpNumbersFromForm(c, &req.TelpNumbers); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	if err := c.Validate(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	user := c.Get("user")
	userID := ""
	if user != nil {
		if userModel, ok := user.(models.User); ok {
			userID = userModel.ID.String()
		}
	}
	res, err := h.Usecase.Create(c.Request().Context(), req, userID)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	// Get contacts for this expedition
	contacts, err := h.Usecase.GetContactsByExpeditionID(c.Request().Context(), res.ID.String())
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(dto.ToRespExpedition(*res, contacts))
	return c.JSON(http.StatusOK, resp)
}

// Update godoc
// @Summary		Update expedition
// @Description	Update an existing expedition's information. Accepts JSON body with telp_numbers (array of objects where area_code optional and phone_number required, contoh: [{&quot;area_code&quot;:&quot;022&quot;,&quot;phone_number&quot;:&quot;1112223355&quot;}, {&quot;area_code&quot;:&quot;022&quot;,&quot;phone_number&quot;:&quot;1112223366&quot;}]) and phone_numbers arrays. First index of telp_numbers array will automatically become primary telp, and first index of phone_numbers array will automatically become primary hp. Phone numbers can be duplicated across different expeditions. Existing contacts will be hard deleted before new ones are created. The response includes full expedition details with all contacts. Requires 'api.master-data.expedition.update' permission.
// @Tags			Expedition
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			id		path	string					true	"Expedition UUID"
// @Param			request	body	dto.ReqUpdateExpedition	true	"Updated expedition data. Fields: expedition_name (required), address (max 255 chars), telp_numbers (array, first index becomes primary telp), phone_numbers (array, first index becomes primary hp), notes (optional)"
// @Success		200		{object}	response.NonPaginationResponse{data=dto.RespExpedition}	"Successfully updated expedition with full details including contacts"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - validation error or duplicate phone number"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Failure		404		{object}	response.NonPaginationResponse	"Expedition not found"
// @Router			/v1/expedition/{id} [put]
func (h *ExpeditionHandler) Update(c echo.Context) error {
	id := c.Param("id")
	req := new(dto.ReqUpdateExpedition)
	if err := c.Bind(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	if err := bindExpeditionTelpNumbersFromForm(c, &req.TelpNumbers); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	if err := c.Validate(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	user := c.Get("user")
	userID := ""
	if user != nil {
		if userModel, ok := user.(models.User); ok {
			userID = userModel.ID.String()
		}
	}
	_, err := h.Usecase.Update(c.Request().Context(), id, req, userID)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	// Get expedition detail for response
	res, err := h.Usecase.GetByID(c.Request().Context(), id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	// Get contacts for this expedition
	contacts, err := h.Usecase.GetContactsByExpeditionID(c.Request().Context(), id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(dto.ToRespExpedition(*res, contacts))
	return c.JSON(http.StatusOK, resp)
}

// Delete godoc
// @Summary		Soft delete expedition
// @Description	Soft delete an existing expedition by ID. The expedition will be marked as deleted (deleted_at is set) but remains in the database. Requires 'api.master-data.expedition.delete' permission.
// @Tags			Expedition
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			id		path	string	true	"Expedition UUID"
// @Success		200		{object}	response.NonPaginationResponse	"Successfully soft deleted expedition"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - invalid UUID"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Failure		404		{object}	response.NonPaginationResponse	"Expedition not found"
// @Router			/v1/expedition/{id} [delete]
func (h *ExpeditionHandler) Delete(c echo.Context) error {
	id := c.Param("id")
	user := c.Get("user")
	userID := ""
	if user != nil {
		if userModel, ok := user.(models.User); ok {
			userID = userModel.ID.String()
		}
	}
	if err := h.Usecase.Delete(c.Request().Context(), id, userID); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(Response{Message: constants.ExpeditionDeleteSuccess})
	return c.JSON(http.StatusOK, resp)
}

// GetIndex godoc
// @Summary		Get list of expeditions with pagination
// @Description	Retrieve a paginated list of expeditions with optional search and filters. Supports multiple filter values for each field. Only returns non-deleted expeditions. Requires 'api.master-data.expedition.view' permission.
// @Tags			Expedition
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			page			query		int							false	"Page number (default: 1)"
// @Param			per_page		query		int							false	"Items per page (default: 10)"
// @Param			sort_by			query		string						false	"Sort column (allowed: id, expedition_code, expedition_name, address, created_at, updated_at)"
// @Param			sort_order		query		string						false	"Sort order: asc or desc (default: desc)"
// @Param			search			query		string						false	"Search keyword (searches in expedition_name, expedition_code, address, and phone numbers from contacts)"
// @Param			expedition_codes	query		[]string					false	"Filter by expedition codes (multiple values)"
// @Param			expedition_names	query		[]string					false	"Filter by expedition names (multiple values)"
// @Param			addresses		query		[]string					false	"Filter by addresses (multiple values)"
// @Param			telp_numbers	query		[]string					false	"Filter by telp numbers (multiple values)"
// @Param			phone_numbers	query		[]string					false	"Filter by phone numbers (multiple values)"
// @Success		200				{object}	response.PaginationResponse{data=[]dto.RespExpeditionIndex}	"Successfully retrieved expeditions"
// @Failure		400				{object}	response.NonPaginationResponse	"Bad request - invalid query parameters"
// @Failure		401				{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403				{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Router			/v1/expedition [get]
func (h *ExpeditionHandler) GetIndex(c echo.Context) error {
	pageRequest := c.Get("page_request").(*request.PageRequest)

	// validate filter req.
	// initialize filter
	filter := new(dto.ReqExpeditionIndexFilter)

	// Bind form-data to the DTO
	if err := c.Bind(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	// Validate the request if necessary
	if err := c.Validate(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	res, total, err := h.Usecase.GetIndex(c.Request().Context(), *pageRequest, *filter)

	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	respExpedition := []dto.RespExpeditionIndex{}

	for _, v := range res {
		respExpedition = append(respExpedition, dto.ToRespExpeditionIndex(v))
	}

	respPag := response.PaginationResponse{}
	respPag, err = respPag.SetResponse(respExpedition, total, pageRequest.PerPage, pageRequest.Page)

	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	return c.JSON(http.StatusOK, respPag)
}

// GetByID godoc
// @Summary		Get expedition by ID
// @Description	Retrieve a single expedition by its UUID. The response includes full expedition details with all contacts (telp_numbers and phone_numbers arrays). Only returns non-deleted expeditions. Requires 'api.master-data.expedition.view' permission.
// @Tags			Expedition
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			id		path	string	true	"Expedition UUID"
// @Success		200		{object}	response.NonPaginationResponse{data=dto.RespExpedition}	"Successfully retrieved expedition with full details including contacts"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - invalid UUID"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Failure		404		{object}	response.NonPaginationResponse	"Expedition not found"
// @Router			/v1/expedition/{id} [get]
func (h *ExpeditionHandler) GetByID(c echo.Context) error {
	id := c.Param("id")
	res, err := h.Usecase.GetByID(c.Request().Context(), id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	// Get contacts for this expedition
	contacts, err := h.Usecase.GetContactsByExpeditionID(c.Request().Context(), id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(dto.ToRespExpedition(*res, contacts))
	return c.JSON(http.StatusOK, resp)
}

// Export godoc
// @Summary		Export expeditions to Excel
// @Description	Export expeditions to Excel file (.xlsx) with optional search and filter. Same search and filter logic as index but without pagination. Supports multiple filter values for each field. Only exports non-deleted expeditions. Excel file includes: Kode Ekspedisi, Nama Ekspedisi, Alamat, Telp, Phone, Update Date. Requires 'api.master-data.expedition.export' permission.
// @Tags			Expedition
// @Accept			json
// @Produce		application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
// @Security		BearerAuth
// @Param			search			query		string						false	"Search keyword (searches in expedition_name, expedition_code, address, and phone numbers from contacts)"
// @Param			expedition_codes	query		[]string					false	"Filter by expedition codes (multiple values)"
// @Param			expedition_names	query		[]string					false	"Filter by expedition names (multiple values)"
// @Param			addresses		query		[]string					false	"Filter by addresses (multiple values)"
// @Param			telp_numbers	query		[]string					false	"Filter by telp numbers (multiple values)"
// @Param			phone_numbers	query		[]string					false	"Filter by phone numbers (multiple values)"
// @Success		200				{file}		binary	"Excel file (expeditions.xlsx) with expeditions data"
// @Failure		400				{object}	response.NonPaginationResponse	"Bad request - invalid query parameters"
// @Failure		401				{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403				{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Router			/v1/expedition/export [get]
func (h *ExpeditionHandler) Export(c echo.Context) error {
	// validate filter req.
	// initialize filter
	filter := new(dto.ReqExpeditionIndexFilter)

	// Bind form-data to the DTO
	if err := c.Bind(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	// Validate the request if necessary
	if err := c.Validate(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	excelBytes, err := h.Usecase.Export(c.Request().Context(), *filter)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	c.Response().Header().Set(echo.HeaderContentType, constants.ExcelContent)
	c.Response().Header().Set(constants.FieldContentDisposition, constants.ExcelContentDisposition("expeditions.xlsx"))
	return c.Blob(http.StatusOK, constants.ExcelContent, excelBytes)
}

func bindExpeditionTelpNumbersFromForm(c echo.Context, telpNumbers *[]dto.TelpNumberItem) error {
	raw := strings.TrimSpace(c.FormValue("telp_numbers"))
	if raw == "" {
		return nil
	}

	var parsed []dto.TelpNumberItem
	if err := json.Unmarshal([]byte(raw), &parsed); err != nil {
		return fmt.Errorf("invalid telp_numbers format: %w", err)
	}

	*telpNumbers = parsed
	return nil
}
