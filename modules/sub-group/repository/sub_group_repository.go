package repository

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/rendyfutsuy/base-go/constants"
	"github.com/rendyfutsuy/base-go/helpers/request"
	"github.com/rendyfutsuy/base-go/models"
	"github.com/rendyfutsuy/base-go/modules/sub-group/dto"
	rsearchsubgroup "github.com/rendyfutsuy/base-go/modules/sub-group/repository/searches"
	"gorm.io/gorm"
)

type subGroupRepository struct {
	DB *gorm.DB
}

func NewSubGroupRepository(db *gorm.DB) *subGroupRepository {
	return &subGroupRepository{
		DB: db,
	}
}

func (r *subGroupRepository) Create(ctx context.Context, goodsGroupID uuid.UUID, name string, createdBy string) (*models.SubGroup, error) {
	now := time.Now().UTC()
	sg := &models.SubGroup{
		GroupID:   goodsGroupID,
		Name:      name,
		CreatedAt: now,
		CreatedBy: createdBy,
		UpdatedAt: now,
		UpdatedBy: createdBy,
	}
	// Omit subgroup_code to let database trigger generate it with formatted 2-digit code
	// Trigger will automatically generate code like "01", "02", etc. based on sequence
	if err := r.DB.WithContext(ctx).Omit("subgroup_code").Create(sg).Error; err != nil {
		return nil, err
	}
	// if sg not update, return error
	if sg.ID == uuid.Nil {
		return nil, errors.New(constants.SubGroupCreateFailedIDNotSet)
	}
	// Reload to get the generated subgroup_code from database (generated by trigger)
	if err := r.DB.WithContext(ctx).Select("id", "groups_id", "subgroup_code", "name", "created_at", "created_by", "updated_at", "updated_by").Where("id = ?", sg.ID).First(sg).Error; err != nil {
		return nil, err
	}
	return sg, nil
}

func (r *subGroupRepository) Update(ctx context.Context, id uuid.UUID, goodsGroupID uuid.UUID, name string, updatedBy string) (*models.SubGroup, error) {
	updates := map[string]interface{}{
		"groups_id":  goodsGroupID,
		"name":       name,
		"updated_at": time.Now().UTC(),
		"updated_by": updatedBy,
	}
	err := r.DB.WithContext(ctx).Model(&models.SubGroup{}).
		Where("id = ? AND deleted_at IS NULL", id).
		Updates(updates).Error
	if err != nil {
		return nil, err
	}
	// Re-fetch with deletable status
	return r.GetByID(ctx, id)
}

func (r *subGroupRepository) Delete(ctx context.Context, id uuid.UUID, deletedBy string) error {
	updates := map[string]interface{}{
		"deleted_at": time.Now().UTC(),
		"deleted_by": deletedBy,
	}
	return r.DB.WithContext(ctx).Model(&models.SubGroup{}).
		Where("id = ? AND deleted_at IS NULL", id).
		Updates(updates).Error
}

func (r *subGroupRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.SubGroup, error) {
	sg := &models.SubGroup{}
	err := r.DB.WithContext(ctx).
		Table("sub_groups sg").
		Select(`
			sg.id,
			sg.groups_id,
			sg.subgroup_code,
			sg.name,
			sg.created_at,
			sg.created_by,
			sg.updated_at,
			sg.updated_by,
			gg.name as groups_name,
			NOT EXISTS (
				SELECT 1 FROM types t
				WHERE t.subgroup_id = sg.id AND t.deleted_at IS NULL
			) as deletable
		`).
		Joins("LEFT JOIN groups gg ON sg.groups_id = gg.id AND gg.deleted_at IS NULL").
		Where("sg.id = ? AND sg.deleted_at IS NULL", id).
		Scan(sg).Error
	if err != nil {
		return nil, err
	}
	// Scan() doesn't return error for record not found, so check if ID is nil
	if sg.ID == uuid.Nil {
		return nil, gorm.ErrRecordNotFound
	}
	return sg, nil
}

func (r *subGroupRepository) ExistsByName(ctx context.Context, goodsGroupID uuid.UUID, name string, excludeID uuid.UUID) (bool, error) {
	var count int64
	q := r.DB.WithContext(ctx).Unscoped().Model(&models.SubGroup{}).Where("groups_id = ? AND name = ?", goodsGroupID, name)
	if excludeID != uuid.Nil {
		q = q.Where("id <> ?", excludeID)
	}
	if err := q.Count(&count).Error; err != nil {
		return false, err
	}
	return count > 0, nil
}

func (r *subGroupRepository) ExistsInTypes(ctx context.Context, subGroupID uuid.UUID) (bool, error) {
	var count int64
	err := r.DB.WithContext(ctx).
		Model(&models.Type{}).
		Where("subgroup_id = ? AND deleted_at IS NULL", subGroupID).
		Count(&count).Error
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (r *subGroupRepository) GetIndex(ctx context.Context, req request.PageRequest, filter dto.ReqSubGroupIndexFilter) ([]models.SubGroup, int, error) {
	var subGroups []models.SubGroup
	query := r.DB.WithContext(ctx).
		Table("sub_groups sg").
		Select(`
			sg.id,
			sg.groups_id,
			sg.subgroup_code,
			sg.name,
			sg.created_at,
			sg.updated_at,
			gg.name as groups_name,
			NOT EXISTS (
				SELECT 1 FROM types t
				WHERE t.subgroup_id = sg.id AND t.deleted_at IS NULL
			) as deletable
		`).
		Joins("LEFT JOIN groups gg ON sg.groups_id = gg.id AND gg.deleted_at IS NULL").
		Where("sg.deleted_at IS NULL")

		// Apply search from PageRequest
	searchQuery := req.Search
	query = request.ApplySearchConditionFromInterface(query, searchQuery, rsearchsubgroup.NewSubGroupSearchHelper())

	// Apply filters with multiple values support
	if len(filter.SubgroupCodes) > 0 {
		query = query.Where("sg.subgroup_code IN (?)", filter.SubgroupCodes)
	}
	if len(filter.Names) > 0 {
		query = query.Where("sg.name IN (?)", filter.Names)
	}
	if len(filter.GroupIDs) > 0 {
		query = query.Where("sg.groups_id IN (?)", filter.GroupIDs)
	}

	// Pagination
	// Use Scan() for JOIN queries with custom SELECT
	total, err := request.ApplyPagination(query, req, request.PaginationConfig{
		DefaultSortBy:      "sg.created_at",
		DefaultSortOrder:   "DESC",
		MaxPerPage:         100,
		SortMapping:        mapSubGroupIndexSortColumn,
		NaturalSortColumns: []string{"sg.name"}, // Enable natural sorting for sg.name
	}, &subGroups)
	if err != nil {
		return nil, 0, err
	}
	return subGroups, total, nil
}

func (r *subGroupRepository) GetAll(ctx context.Context, filter dto.ReqSubGroupIndexFilter) ([]models.SubGroup, error) {
	var subGroups []models.SubGroup
	query := r.DB.WithContext(ctx).
		Table("sub_groups sg").
		Select(`
			sg.id,
			sg.groups_id,
			sg.subgroup_code,
			sg.name,
			sg.created_at,
			sg.updated_at,
			gg.name as groups_name
		`).
		Joins("LEFT JOIN groups gg ON sg.groups_id = gg.id AND gg.deleted_at IS NULL").
		Where("sg.deleted_at IS NULL")

	// Apply search from filter
	query = request.ApplySearchConditionFromInterface(query, filter.Search, rsearchsubgroup.NewSubGroupSearchHelper())

	// Apply filters with multiple values support
	if len(filter.SubgroupCodes) > 0 {
		query = query.Where("sg.subgroup_code IN (?)", filter.SubgroupCodes)
	}
	if len(filter.Names) > 0 {
		query = query.Where("sg.name IN (?)", filter.Names)
	}
	if len(filter.GroupIDs) > 0 {
		query = query.Where("sg.groups_id IN (?)", filter.GroupIDs)
	}

	// Determine sorting with natural sorting support
	sortExpression := request.BuildSortExpressionForExport(
		filter.SortBy,
		filter.SortOrder,
		"sg.created_at",
		"DESC",
		mapSubGroupIndexSortColumn,
		[]string{"sg.name"}, // Enable natural sorting for sub-group name
	)

	// Order results
	// Use Scan() for JOIN queries with custom SELECT
	if err := query.Order(sortExpression).Scan(&subGroups).Error; err != nil {
		return nil, err
	}
	return subGroups, nil
}
