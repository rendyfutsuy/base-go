package http

import (
	"net/http"

	"github.com/go-playground/validator/v10"
	"github.com/labstack/echo/v4"
	"github.com/rendyfutsuy/base-go/constants"
	"github.com/rendyfutsuy/base-go/helpers/middleware"
	_reqContext "github.com/rendyfutsuy/base-go/helpers/middleware/request"
	"github.com/rendyfutsuy/base-go/helpers/request"
	"github.com/rendyfutsuy/base-go/helpers/response"
	sub_group "github.com/rendyfutsuy/base-go/modules/sub-group"
	"github.com/rendyfutsuy/base-go/modules/sub-group/dto"
)

type ResponseError struct {
	Message string `json:"message"`
}

type Response struct {
	Message string `json:"message"`
}

type SubGroupHandler struct {
	Usecase              sub_group.Usecase
	validator            *validator.Validate
	mwPageRequest        _reqContext.IMiddlewarePageRequest
	middlewareAuth       middleware.IMiddlewareAuth
	middlewarePermission middleware.IMiddlewarePermission
}

func NewSubGroupHandler(e *echo.Echo, uc sub_group.Usecase, mwP _reqContext.IMiddlewarePageRequest, auth middleware.IMiddlewareAuth, middlewarePermission middleware.IMiddlewarePermission) {
	h := &SubGroupHandler{Usecase: uc, validator: validator.New(), mwPageRequest: mwP, middlewareAuth: auth, middlewarePermission: middlewarePermission}

	r := e.Group("/v1/sub-group")
	r.Use(h.middlewareAuth.AuthorizationCheck)

	// Permissions
	// View:   sub-group.view
	// Create: sub-group.create
	// Update: sub-group.update
	// Delete: sub-group.delete
	// Export: sub-group.export
	permissionToView := []string{"sub-group.view"}
	permissionToCreate := []string{"sub-group.create"}
	permissionToUpdate := []string{"sub-group.update"}
	permissionToDelete := []string{"sub-group.delete"}
	permissionToExport := []string{"sub-group.export"}

	// Index with pagination + search
	r.GET("", h.GetIndex, middleware.RequireActivatedUser, h.mwPageRequest.PageRequestCtx, h.middlewarePermission.PermissionValidation(permissionToView))

	// Export (no pagination, same filters) - must be before /:id to avoid route conflict
	r.GET("/export", h.Export, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToExport))

	// Get by ID (detail) - must be after /export to avoid route conflict
	r.GET("/:id", h.GetByID, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToView))

	// Create
	r.POST("", h.Create, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToCreate))

	// Update
	r.PUT("/:id", h.Update, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToUpdate))

	// Delete
	r.DELETE("/:id", h.Delete, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToDelete))
}

// Create godoc
// @Summary		Create a new sub-group
// @Description	Create a new sub-group with provided goods_group_id and name. Name must be unique within the same goods_group. Subgroup code is automatically generated by the database trigger with 2-digit format (e.g., "01", "02", "05", "10"). The code is generated sequentially based on the sequence.
// @Tags			Sub Golongan
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			request	body		dto.ReqCreateSubGroup	true	"Sub-group creation data. Fields: goods_group_id (required, UUID), name (required, max 255 chars, uppercase letters only)"
// @Success		200		{object}	response.NonPaginationResponse{data=dto.RespSubGroup}	"Successfully created sub-group with auto-generated subgroup_code in 2-digit format"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - validation error or duplicate name in goods_group"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Router			/v1/sub-group [post]
func (h *SubGroupHandler) Create(c echo.Context) error {
	req := new(dto.ReqCreateSubGroup)
	if err := c.Bind(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	if err := c.Validate(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	user := c.Get("user")
	_ = user // not used; keep signature parity
	res, err := h.Usecase.Create(c, req, "")
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	// Set deletable to true for newly created sub-group (no types reference yet)
	res.Deletable = true
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(dto.ToRespSubGroup(*res))
	return c.JSON(http.StatusOK, resp)
}

// Update godoc
// @Summary		Update sub-group
// @Description	Update an existing sub-group's information. Name must be unique within the same goods_group. Subgroup code cannot be updated as it is auto-generated. The response includes the current subgroup_code in 2-digit format.
// @Tags			Sub Golongan
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			id		path	string					true	"Sub-group UUID"
// @Param			request	body	dto.ReqUpdateSubGroup	true	"Updated sub-group data. Fields: goods_group_id (required, UUID), name (required, max 255 chars, uppercase letters only). Note: subgroup_code is read-only and cannot be updated."
// @Success		200		{object}	response.NonPaginationResponse{data=dto.RespSubGroup}	"Successfully updated sub-group with subgroup_code in 2-digit format"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - validation error or duplicate name in goods_group"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Failure		404		{object}	response.NonPaginationResponse	"Sub-group not found"
// @Router			/v1/sub-group/{id} [put]
func (h *SubGroupHandler) Update(c echo.Context) error {
	id := c.Param("id")
	req := new(dto.ReqUpdateSubGroup)
	if err := c.Bind(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	if err := c.Validate(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	res, err := h.Usecase.Update(c, id, req, "")
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(dto.ToRespSubGroup(*res))
	return c.JSON(http.StatusOK, resp)
}

// Delete godoc
// @Summary		Soft delete sub-group
// @Description	Soft delete an existing sub-group by ID. The sub-group will be marked as deleted (deleted_at is set) but remains in the database. Requires 'api.master-data.sub-group.delete' permission.
// @Tags			Sub Golongan
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			id		path	string	true	"Sub-group UUID"
// @Success		200		{object}	response.NonPaginationResponse	"Successfully soft deleted sub-group"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - invalid UUID"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Failure		404		{object}	response.NonPaginationResponse	"Sub-group not found"
// @Router			/v1/sub-group/{id} [delete]
func (h *SubGroupHandler) Delete(c echo.Context) error {
	id := c.Param("id")
	if err := h.Usecase.Delete(c, id, ""); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(Response{Message: constants.SubGroupDeleteSuccess})
	return c.JSON(http.StatusOK, resp)
}

// GetIndex godoc
// @Summary		Get list of sub-groups with pagination
// @Description	Retrieve a paginated list of sub-groups with optional search and filters. Supports multiple filter values for subgroup_code, name, and goods_group_id. Subgroup codes are in 2-digit string format (e.g., "01", "02", "05", "10"). Only returns non-deleted sub-groups. Supports sorting by DTO field names (e.g., subgroup_code, name, goods_group_name, created_at, updated_at).
// @Tags			Sub Golongan
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			page			query		int							false	"Page number (default: 1)"
// @Param			per_page		query		int							false	"Items per page (default: 10)"
// @Param			sort_by			query		string						false	"Sort by field (e.g., subgroup_code, name, goods_group_name, created_at, updated_at)"
// @Param			sort_order		query		string						false	"Sort order (ASC or DESC, default: DESC)"
// @Param			search			query		string						false	"Search keyword (searches in subgroup_code and name)"
// @Param			subgroup_codes	query		[]string					false	"Filter by subgroup codes (multiple values, format: "01", "02", etc.)"
// @Param			names			query		[]string					false	"Filter by names (multiple values)"
// @Param			goods_group_ids	query		[]string					false	"Filter by goods group IDs (multiple values, UUIDs)"
// @Success		200				{object}	response.PaginationResponse{data=[]dto.RespSubGroupIndex}	"Successfully retrieved sub-groups"
// @Failure		400				{object}	response.NonPaginationResponse	"Bad request - invalid query parameters"
// @Failure		401				{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403				{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Router			/v1/sub-group [get]
func (h *SubGroupHandler) GetIndex(c echo.Context) error {
	pageRequest := c.Get("page_request").(*request.PageRequest)

	// validate filter req.
	// initialize filter
	filter := new(dto.ReqSubGroupIndexFilter)

	// Bind form-data to the DTO
	if err := c.Bind(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	// Validate the request if necessary
	if err := c.Validate(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	res, total, err := h.Usecase.GetIndex(c, *pageRequest, *filter)

	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	respSubGroup := []dto.RespSubGroupIndex{}

	for _, v := range res {
		respSubGroup = append(respSubGroup, dto.ToRespSubGroupIndex(v))
	}

	respPag := response.PaginationResponse{}
	respPag, err = respPag.SetResponse(respSubGroup, total, pageRequest.PerPage, pageRequest.Page)

	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	return c.JSON(http.StatusOK, respPag)
}

// GetByID godoc
// @Summary		Get sub-group by ID
// @Description	Retrieve a single sub-group by its UUID. The response includes subgroup_code in 2-digit string format (e.g., "01", "02", "05", "10") and goods_group_name to identify which goods group this sub-group belongs to. Only returns non-deleted sub-groups.
// @Tags			Sub Golongan
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			id		path		string	true	"Sub-group UUID"
// @Success		200		{object}	response.NonPaginationResponse{data=dto.RespSubGroup}	"Successfully retrieved sub-group with subgroup_code in 2-digit format and goods_group_name"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - invalid UUID"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Failure		404		{object}	response.NonPaginationResponse	"Sub-group not found"
// @Router			/v1/sub-group/{id} [get]
func (h *SubGroupHandler) GetByID(c echo.Context) error {
	id := c.Param("id")
	res, err := h.Usecase.GetByID(c, id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(dto.ToRespSubGroup(*res))
	return c.JSON(http.StatusOK, resp)
}

// Export godoc
// @Summary		Export sub-groups to Excel
// @Description	Export sub-groups to Excel file (.xlsx) with optional search and filter. Same search and filter logic as index but without pagination. Supports multiple filter values for each field. Only exports non-deleted sub-groups. Excel file includes: Kode Sub Golongan (2-digit format like "01", "02"), Nama Sub Golongan, Nama Golongan, Updated Date. Requires 'sub-group.export' permission.
// @Tags			Sub Golongan
// @Accept			json
// @Produce		application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
// @Security		BearerAuth
// @Param			search			query		string						false	"Search keyword (searches in subgroup_code and name)"
// @Param			subgroup_codes	query		[]string					false	"Filter by subgroup codes (multiple values, format: "01", "02", etc.)"
// @Param			names			query		[]string					false	"Filter by names (multiple values)"
// @Param			goods_group_ids	query		[]string					false	"Filter by goods group IDs (multiple values, UUIDs)"
// @Param			sort_by			query		string						false	"Sort by field (e.g., subgroup_code, name, goods_group_name, created_at, updated_at)"
// @Param			sort_order		query		string						false	"Sort order (ASC or DESC)"
// @Success		200				{file}		binary	"Excel file (sub-groups.xlsx) with sub-groups data including subgroup_code in 2-digit format"
// @Failure		400				{object}	response.NonPaginationResponse	"Bad request - invalid query parameters"
// @Failure		401				{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403				{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Router			/v1/sub-group/export [get]
func (h *SubGroupHandler) Export(c echo.Context) error {
	// validate filter req.
	// initialize filter
	filter := new(dto.ReqSubGroupIndexFilter)

	// Bind form-data to the DTO
	if err := c.Bind(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	// Validate the request if necessary
	if err := c.Validate(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	excelBytes, err := h.Usecase.Export(c, *filter)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	c.Response().Header().Set(echo.HeaderContentType, constants.ExcelContent)
	c.Response().Header().Set(constants.FieldContentDisposition, constants.ExcelContentDisposition("sub-groups.xlsx"))
	return c.Blob(http.StatusOK, constants.ExcelContent, excelBytes)
}
