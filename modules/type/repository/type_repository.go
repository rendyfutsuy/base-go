package repository

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/rendyfutsuy/base-go/constants"
	"github.com/rendyfutsuy/base-go/helpers/request"
	"github.com/rendyfutsuy/base-go/models"
	"github.com/rendyfutsuy/base-go/modules/type/dto"
	"gorm.io/gorm"
)

type typeRepository struct {
	DB *gorm.DB
}

func NewTypeRepository(db *gorm.DB) *typeRepository {
	return &typeRepository{DB: db}
}

func (r *typeRepository) Create(ctx context.Context, subgroupID uuid.UUID, name string, createdBy string) (*models.Type, error) {
	now := time.Now().UTC()
	t := &models.Type{
		SubgroupID: subgroupID,
		Name:       name,
		CreatedAt:  now,
		CreatedBy:  createdBy,
		UpdatedAt:  now,
		UpdatedBy:  createdBy,
	}
	// Omit type_code to let database generate it using DEFAULT generate_type_code()
	if err := r.DB.WithContext(ctx).Omit("type_code").Create(t).Error; err != nil {
		return nil, err
	}
	// if t not update, return error
	if t.ID == uuid.Nil {
		return nil, errors.New(constants.TypeCreateFailedIDNotSet)
	}
	// Reload to get the generated type_code from database (generated by trigger)
	if err := r.DB.WithContext(ctx).Select("id", "subgroup_id", "type_code", "name", "created_at", "created_by", "updated_at", "updated_by").Where("id = ?", t.ID).First(t).Error; err != nil {
		return nil, err
	}
	return t, nil
}

func (r *typeRepository) Update(ctx context.Context, id uuid.UUID, subgroupID uuid.UUID, name string, updatedBy string) (*models.Type, error) {
	updates := map[string]interface{}{
		"subgroup_id": subgroupID,
		"name":        name,
		"updated_at":  time.Now().UTC(),
		"updated_by":  updatedBy,
	}
	t := &models.Type{}
	err := r.DB.WithContext(ctx).Model(&models.Type{}).
		Where("id = ? AND deleted_at IS NULL", id).
		Updates(updates).
		First(t).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, err
		}
		return nil, err
	}
	return t, nil
}

func (r *typeRepository) Delete(ctx context.Context, id uuid.UUID, deletedBy string) error {
	updates := map[string]interface{}{
		"deleted_at": time.Now().UTC(),
		"deleted_by": deletedBy,
	}
	return r.DB.WithContext(ctx).Model(&models.Type{}).
		Where("id = ? AND deleted_at IS NULL", id).
		Updates(updates).Error
}

func (r *typeRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Type, error) {
	t := &models.Type{}
	query := r.DB.WithContext(ctx).
		Table("types t").
		Select(`
			t.id,
			t.subgroup_id,
			t.type_code,
			t.name,
			t.created_at,
			t.created_by,
			t.updated_at,
			t.updated_by,
			sg.name as subgroup_name,
			sg.goods_group_id as goods_group_id,
			gg.name as goods_group_name
		`).
		Joins("LEFT JOIN sub_groups sg ON t.subgroup_id = sg.id AND sg.deleted_at IS NULL").
		Joins("LEFT JOIN goods_group gg ON sg.goods_group_id = gg.id AND gg.deleted_at IS NULL").
		Where("t.id = ? AND t.deleted_at IS NULL", id)

	err := query.Scan(t).Error
	if err != nil {
		return nil, err
	}
	// Scan() doesn't return error for record not found, so check if ID is nil
	if t.ID == uuid.Nil {
		return nil, gorm.ErrRecordNotFound
	}
	return t, nil
}

func (r *typeRepository) ExistsByNameInSubgroup(ctx context.Context, subgroupID uuid.UUID, name string, excludeID uuid.UUID) (bool, error) {
	var count int64
	q := r.DB.WithContext(ctx).Unscoped().Model(&models.Type{}).Where("subgroup_id = ? AND name = ?", subgroupID, name)
	if excludeID != uuid.Nil {
		q = q.Where("id <> ?", excludeID)
	}
	if err := q.Count(&count).Error; err != nil {
		return false, err
	}
	return count > 0, nil
}

func (r *typeRepository) GetIndex(ctx context.Context, req request.PageRequest, filter dto.ReqTypeIndexFilter) ([]models.Type, int, error) {
	var types []models.Type
	query := r.DB.WithContext(ctx).
		Table("types t").
		Select(`
			t.id,
			t.subgroup_id,
			t.type_code,
			t.name,
			t.created_at,
			t.updated_at,
			sg.name as subgroup_name,
			gg.name as goods_group_name
		`).
		Joins("LEFT JOIN sub_groups sg ON t.subgroup_id = sg.id AND sg.deleted_at IS NULL").
		Joins("LEFT JOIN goods_group gg ON sg.goods_group_id = gg.id AND gg.deleted_at IS NULL").
		Where("t.deleted_at IS NULL")

	// Apply search from PageRequest
	searchQuery := req.Search
	query = request.ApplySearchCondition(query, searchQuery, []string{"t.type_code", "t.name"})

	// Apply filters with multiple values support
	if len(filter.TypeCodes) > 0 {
		query = query.Where("t.type_code IN (?)", filter.TypeCodes)
	}
	if len(filter.Names) > 0 {
		query = query.Where("t.name IN (?)", filter.Names)
	}
	if len(filter.SubgroupIDs) > 0 {
		// Convert string UUIDs to uuid.UUID for query
		subgroupUUIDs := make([]uuid.UUID, 0, len(filter.SubgroupIDs))
		for _, idStr := range filter.SubgroupIDs {
			if id, err := uuid.Parse(idStr); err == nil {
				subgroupUUIDs = append(subgroupUUIDs, id)
			}
		}
		if len(subgroupUUIDs) > 0 {
			query = query.Where("t.subgroup_id IN (?)", subgroupUUIDs)
		}
	}

	// Pagination
	// Use Scan() for JOIN queries with custom SELECT
	total, err := request.ApplyPagination(query, req, request.PaginationConfig{
		DefaultSortBy:    "t.created_at",
		DefaultSortOrder: "DESC",
		AllowedColumns:   []string{"id", "subgroup_id", "type_code", "name", "created_at", "updated_at"},
		ColumnPrefix:     "t.",
		MaxPerPage:       100,
	}, &types)
	if err != nil {
		return nil, 0, err
	}
	return types, total, nil
}

func (r *typeRepository) GetAll(ctx context.Context, filter dto.ReqTypeIndexFilter) ([]models.Type, error) {
	var types []models.Type
	query := r.DB.WithContext(ctx).
		Table("types t").
		Select(`
			t.id,
			t.subgroup_id,
			t.type_code,
			t.name,
			t.created_at,
			t.updated_at,
			sg.name as subgroup_name,
			gg.name as goods_group_name
		`).
		Joins("LEFT JOIN sub_groups sg ON t.subgroup_id = sg.id AND sg.deleted_at IS NULL").
		Joins("LEFT JOIN goods_group gg ON sg.goods_group_id = gg.id AND gg.deleted_at IS NULL").
		Where("t.deleted_at IS NULL")

	// Apply search from filter
	query = request.ApplySearchCondition(query, filter.Search, []string{"t.type_code", "t.name"})

	// Apply filters with multiple values support
	if len(filter.TypeCodes) > 0 {
		query = query.Where("t.type_code IN (?)", filter.TypeCodes)
	}
	if len(filter.Names) > 0 {
		query = query.Where("t.name IN (?)", filter.Names)
	}
	if len(filter.SubgroupIDs) > 0 {
		// Convert string UUIDs to uuid.UUID for query
		subgroupUUIDs := make([]uuid.UUID, 0, len(filter.SubgroupIDs))
		for _, idStr := range filter.SubgroupIDs {
			if id, err := uuid.Parse(idStr); err == nil {
				subgroupUUIDs = append(subgroupUUIDs, id)
			}
		}
		if len(subgroupUUIDs) > 0 {
			query = query.Where("t.subgroup_id IN (?)", subgroupUUIDs)
		}
	}

	// Order by created_at DESC (no pagination)
	// Use Scan() for JOIN queries with custom SELECT
	if err := query.Order("t.created_at DESC").Scan(&types).Error; err != nil {
		return nil, err
	}
	return types, nil
}
