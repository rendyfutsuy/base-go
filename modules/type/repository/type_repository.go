package repository

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/rendyfutsuy/base-go/constants"
	"github.com/rendyfutsuy/base-go/helpers/request"
	"github.com/rendyfutsuy/base-go/models"
	"github.com/rendyfutsuy/base-go/modules/type/dto"
	"gorm.io/gorm"
)

type typeRepository struct {
	DB *gorm.DB
}

func NewTypeRepository(db *gorm.DB) *typeRepository {
	return &typeRepository{DB: db}
}

func (r *typeRepository) Create(ctx context.Context, subgroupID uuid.UUID, name string, createdBy string) (*models.Type, error) {
	now := time.Now().UTC()
	t := &models.Type{
		SubgroupID: subgroupID,
		Name:       name,
		CreatedAt:  now,
		CreatedBy:  createdBy,
		UpdatedAt:  now,
		UpdatedBy:  createdBy,
	}
	// Omit type_code to let database generate it using DEFAULT generate_type_code()
	if err := r.DB.WithContext(ctx).Omit("type_code").Create(t).Error; err != nil {
		return nil, err
	}
	// if t not update, return error
	if t.ID == uuid.Nil {
		return nil, errors.New(constants.TypeCreateFailedIDNotSet)
	}
	// Reload to get the generated type_code from database (generated by trigger)
	if err := r.DB.WithContext(ctx).Select("id", "subgroup_id", "type_code", "name", "created_at", "created_by", "updated_at", "updated_by").Where("id = ?", t.ID).First(t).Error; err != nil {
		return nil, err
	}
	return t, nil
}

func (r *typeRepository) Update(ctx context.Context, id uuid.UUID, subgroupID uuid.UUID, name string, updatedBy string) (*models.Type, error) {
	updates := map[string]interface{}{
		"subgroup_id": subgroupID,
		"name":        name,
		"updated_at":  time.Now().UTC(),
		"updated_by":  updatedBy,
	}
	err := r.DB.WithContext(ctx).Model(&models.Type{}).
		Where("id = ? AND deleted_at IS NULL", id).
		Updates(updates).Error
	if err != nil {
		return nil, err
	}
	// Re-fetch with deletable status
	return r.GetByID(ctx, id)
}

func (r *typeRepository) Delete(ctx context.Context, id uuid.UUID, deletedBy string) error {
	updates := map[string]interface{}{
		"deleted_at": time.Now().UTC(),
		"deleted_by": deletedBy,
	}
	return r.DB.WithContext(ctx).Model(&models.Type{}).
		Where("id = ? AND deleted_at IS NULL", id).
		Updates(updates).Error
}

func (r *typeRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Type, error) {
	t := &models.Type{}
	query := r.DB.WithContext(ctx).
		Table("types t").
		Select(`
			t.id,
			t.subgroup_id,
			t.type_code,
			t.name,
			t.created_at,
			t.created_by,
			t.updated_at,
			t.updated_by,
			sg.name as subgroup_name,
			sg.goods_group_id as goods_group_id,
			gg.name as goods_group_name,
			NOT EXISTS (
				SELECT 1 FROM backings b
				WHERE b.type_id = t.id AND b.deleted_at IS NULL
			) as deletable
		`).
		Joins("LEFT JOIN sub_groups sg ON t.subgroup_id = sg.id AND sg.deleted_at IS NULL").
		Joins("LEFT JOIN goods_group gg ON sg.goods_group_id = gg.id AND gg.deleted_at IS NULL").
		Where("t.id = ? AND t.deleted_at IS NULL", id)

	err := query.Scan(t).Error
	if err != nil {
		return nil, err
	}
	// Scan() doesn't return error for record not found, so check if ID is nil
	if t.ID == uuid.Nil {
		return nil, gorm.ErrRecordNotFound
	}
	return t, nil
}

func (r *typeRepository) ExistsByNameInSubgroup(ctx context.Context, subgroupID uuid.UUID, name string, excludeID uuid.UUID) (bool, error) {
	var count int64
	q := r.DB.WithContext(ctx).Unscoped().Model(&models.Type{}).Where("subgroup_id = ? AND name = ?", subgroupID, name)
	if excludeID != uuid.Nil {
		q = q.Where("id <> ?", excludeID)
	}
	if err := q.Count(&count).Error; err != nil {
		return false, err
	}
	return count > 0, nil
}

func (r *typeRepository) ExistsInBackings(ctx context.Context, typeID uuid.UUID) (bool, error) {
	var count int64
	err := r.DB.WithContext(ctx).
		Model(&models.Backing{}).
		Where("type_id = ? AND deleted_at IS NULL", typeID).
		Count(&count).Error
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func (r *typeRepository) GetIndex(ctx context.Context, req request.PageRequest, filter dto.ReqTypeIndexFilter) ([]models.Type, int, error) {
	var types []models.Type
	query := r.DB.WithContext(ctx).
		Table("types t").
		Select(`
			t.id,
			t.subgroup_id,
			t.type_code,
			t.name,
			t.created_at,
			t.updated_at,
			sg.name as subgroup_name,
			gg.name as goods_group_name,
			NOT EXISTS (
				SELECT 1 FROM backings b
				WHERE b.type_id = t.id AND b.deleted_at IS NULL
			) as deletable
		`).
		Joins("LEFT JOIN sub_groups sg ON t.subgroup_id = sg.id AND sg.deleted_at IS NULL").
		Joins("LEFT JOIN goods_group gg ON sg.goods_group_id = gg.id AND gg.deleted_at IS NULL").
		Where("t.deleted_at IS NULL")

	// Apply search from PageRequest
	query = request.ApplySearchConditionWithSubqueriesFromInterface(query, req.Search, r)

	// Apply filters with multiple values support
	query = r.ApplyFilters(query, filter)

	// Pagination
	// Use Scan() for JOIN queries with custom SELECT
	total, err := request.ApplyPagination(query, req, request.PaginationConfig{
		DefaultSortBy:      "t.created_at",
		DefaultSortOrder:   "DESC",
		MaxPerPage:         100,
		SortMapping:        mapTypeIndexSortColumn,
		NaturalSortColumns: []string{"t.name"}, // Enable natural sorting for t.name
	}, &types)
	if err != nil {
		return nil, 0, err
	}
	return types, total, nil
}

func (r *typeRepository) GetAll(ctx context.Context, filter dto.ReqTypeIndexFilter) ([]models.Type, error) {
	var types []models.Type
	query := r.DB.WithContext(ctx).
		Table("types t").
		Select(`
			t.id,
			t.subgroup_id,
			t.type_code,
			t.name,
			t.created_at,
			t.updated_at,
			sg.name as subgroup_name,
			gg.name as goods_group_name,
			NOT EXISTS (
				SELECT 1 FROM backings b
				WHERE b.type_id = t.id AND b.deleted_at IS NULL
			) as deletable
		`).
		Joins("LEFT JOIN sub_groups sg ON t.subgroup_id = sg.id AND sg.deleted_at IS NULL").
		Joins("LEFT JOIN goods_group gg ON sg.goods_group_id = gg.id AND gg.deleted_at IS NULL").
		Where("t.deleted_at IS NULL")

	// Apply search from filter
	query = request.ApplySearchCondition(query, filter.Search, []string{"t.type_code", "t.name"})

	// Apply filters with multiple values support
	query = r.ApplyFilters(query, filter)

	// Determine sorting
	sortBy := "t.created_at"
	if mapped := mapTypeIndexSortColumn(filter.SortBy); mapped != "" {
		sortBy = mapped
	}

	// Determine sorting with natural sorting support
	sortExpression := request.BuildSortExpressionForExport(
		sortBy,
		filter.SortOrder,
		"t.created_at",
		"DESC",
		mapTypeIndexSortColumn,
		[]string{"t.name"}, // Enable natural sorting for type name
	)

	// Order results
	// Use Scan() for JOIN queries with custom SELECT
	if err := query.Order(sortExpression).Scan(&types).Error; err != nil {
		return nil, err
	}
	return types, nil
}

// GetSearchColumns returns the list of direct column names for type search
// Implements NeedSubqueryPredefine interface
func (r *typeRepository) GetSearchColumns() []string {
	return []string{
		"t.type_code",
		"t.name",
	}
}

// GetSearchExistsSubqueries returns the list of EXISTS subqueries for type search
// Implements NeedSubqueryPredefine interface
func (r *typeRepository) GetSearchExistsSubqueries() []string {
	return []string{
		"EXISTS (SELECT 1 FROM sub_groups sg WHERE sg.id = t.subgroup_id AND sg.deleted_at IS NULL AND REPLACE(sg.name, ' ', '') ILIKE ?)",
		"EXISTS (SELECT 1 FROM goods_group gg JOIN sub_groups sg2 ON gg.id = sg2.goods_group_id WHERE sg2.id = t.subgroup_id AND gg.deleted_at IS NULL AND sg2.deleted_at IS NULL AND REPLACE(gg.name, ' ', '') ILIKE ?)",
	}
}

// Compile-time check to ensure typeRepository implements NeedSubqueryPredefine interface
var _ request.NeedSubqueryPredefine = (*typeRepository)(nil)
