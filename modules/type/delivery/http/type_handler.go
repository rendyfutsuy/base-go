package http

import (
	"net/http"

	"github.com/go-playground/validator/v10"
	"github.com/labstack/echo/v4"
	"github.com/rendyfutsuy/base-go/constants"
	"github.com/rendyfutsuy/base-go/helpers/middleware"
	_reqContext "github.com/rendyfutsuy/base-go/helpers/middleware/request"
	"github.com/rendyfutsuy/base-go/helpers/request"
	"github.com/rendyfutsuy/base-go/helpers/response"
	"github.com/rendyfutsuy/base-go/models"
	type_module "github.com/rendyfutsuy/base-go/modules/type"
	"github.com/rendyfutsuy/base-go/modules/type/dto"
)

type ResponseError struct {
	Message string `json:"message"`
}

type Response struct {
	Message string `json:"message"`
}

type TypeHandler struct {
	Usecase              type_module.Usecase
	validator            *validator.Validate
	mwPageRequest        _reqContext.IMiddlewarePageRequest
	middlewareAuth       middleware.IMiddlewareAuth
	middlewarePermission middleware.IMiddlewarePermission
}

func NewTypeHandler(e *echo.Echo, uc type_module.Usecase, mwP _reqContext.IMiddlewarePageRequest, auth middleware.IMiddlewareAuth, middlewarePermission middleware.IMiddlewarePermission) {
	h := &TypeHandler{Usecase: uc, validator: validator.New(), mwPageRequest: mwP, middlewareAuth: auth, middlewarePermission: middlewarePermission}

	r := e.Group("v1/type")
	r.Use(h.middlewareAuth.AuthorizationCheck)

	// Permissions
	// View:   type.view
	// Create: type.create
	// Update: type.update
	// Delete: type.delete
	// Export: type.export
	permissionToView := []string{"type.view"}
	permissionToCreate := []string{"type.create"}
	permissionToUpdate := []string{"type.update"}
	permissionToDelete := []string{"type.delete"}
	permissionToExport := []string{"type.export"}

	// Index with pagination + search
	r.GET("", h.GetIndex, middleware.RequireActivatedUser, h.mwPageRequest.PageRequestCtx, h.middlewarePermission.PermissionValidation(permissionToView))

	// Export (no pagination, same filters) - must be before /:id to avoid route conflict
	r.GET("/export", h.Export, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToExport))

	// Get by ID (detail) - must be after /export to avoid route conflict
	r.GET("/:id", h.GetByID, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToView))

	// Create
	r.POST("", h.Create, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToCreate))

	// Update
	r.PUT("/:id", h.Update, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToUpdate))

	// Delete
	r.DELETE("/:id", h.Delete, middleware.RequireActivatedUser, h.middlewarePermission.PermissionValidation(permissionToDelete))
}

// Create godoc
// @Summary		Create a new type
// @Description	Create a new type with provided data. Type code is automatically generated by the system. Requires 'api.master-data.type.create' permission.
// @Tags			Jenis
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			request	body		dto.ReqCreateType	true	"Type creation data. Fields: subgroup_id (required, UUID), name (required, max 255 chars)"
// @Success		200		{object}	response.NonPaginationResponse{data=dto.RespType}	"Successfully created type with auto-generated type_code"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - validation error or duplicate name in subgroup"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Router			/v1/type [post]
func (h *TypeHandler) Create(c echo.Context) error {
	// initialize context from echo
	ctx := c.Request().Context()

	req := new(dto.ReqCreateType)
	if err := c.Bind(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	if err := c.Validate(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	// Get user ID from context
	user := c.Get("user")
	userID := ""
	if user != nil {
		if userModel, ok := user.(models.User); ok {
			userID = userModel.ID.String()
		}
	}

	res, err := h.Usecase.Create(ctx, req, userID)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	// Reload to get subgroup_name from join
	typeDetail, err := h.Usecase.GetByID(ctx, res.ID.String())
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(dto.ToRespType(*typeDetail))
	return c.JSON(http.StatusOK, resp)
}

// Update godoc
// @Summary		Update type
// @Description	Update an existing type's information. Type code cannot be updated. Requires 'api.master-data.type.update' permission.
// @Tags			Jenis
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			id		path	string				true	"Type UUID"
// @Param			request	body	dto.ReqUpdateType	true	"Updated type data. Fields: subgroup_id (required, UUID), name (required, max 255 chars)"
// @Success		200		{object}	response.NonPaginationResponse{data=dto.RespType}	"Successfully updated type"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - validation error or duplicate name in subgroup"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Failure		404		{object}	response.NonPaginationResponse	"Type not found"
// @Router			/v1/type/{id} [put]
func (h *TypeHandler) Update(c echo.Context) error {
	// initialize context from echo
	ctx := c.Request().Context()

	id := c.Param("id")
	req := new(dto.ReqUpdateType)
	if err := c.Bind(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	if err := c.Validate(req); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	// Get user ID from context
	user := c.Get("user")
	userID := ""
	if user != nil {
		if userModel, ok := user.(models.User); ok {
			userID = userModel.ID.String()
		}
	}

	_, err := h.Usecase.Update(ctx, id, req, userID)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	// Reload to get subgroup_name from join
	typeDetail, err := h.Usecase.GetByID(ctx, id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(dto.ToRespType(*typeDetail))
	return c.JSON(http.StatusOK, resp)
}

// Delete godoc
// @Summary		Soft delete type
// @Description	Soft delete an existing type by ID. The type will be marked as deleted (deleted_at is set) but remains in the database. Requires 'api.master-data.type.delete' permission.
// @Tags			Jenis
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			id		path	string	true	"Type UUID"
// @Success		200		{object}	response.NonPaginationResponse	"Successfully soft deleted type"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - invalid UUID"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Failure		404		{object}	response.NonPaginationResponse	"Type not found"
// @Router			/v1/type/{id} [delete]
func (h *TypeHandler) Delete(c echo.Context) error {
	// initialize context from echo
	ctx := c.Request().Context()

	// Get user ID from context
	user := c.Get("user")
	userID := ""
	if user != nil {
		if userModel, ok := user.(models.User); ok {
			userID = userModel.ID.String()
		}
	}

	id := c.Param("id")
	if err := h.Usecase.Delete(ctx, id, userID); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(Response{Message: constants.TypeDeleteSuccess})
	return c.JSON(http.StatusOK, resp)
}

// GetIndex godoc
// @Summary		Get list of types with pagination
// @Description	Retrieve a paginated list of types with optional search and filters. Supports multiple filter values for type_code, subgroup_id, and name. Only returns non-deleted types. Requires 'api.master-data.type.view' permission.
// @Tags			Jenis
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			page			query		int						false	"Page number (default: 1)"
// @Param			per_page		query		int						false	"Items per page (default: 10)"
// @Param			sort_by			query		string					false	"Sort column (allowed: id, subgroup_id, type_code, name, created_at, updated_at)"
// @Param			sort_order		query		string					false	"Sort order: asc or desc (default: desc)"
// @Param			search			query		string					false	"Search keyword (searches in type_code and name)"
// @Param			type_codes		query		[]string				false	"Filter by type codes (multiple values)"
// @Param			subgroup_ids	query		[]string				false	"Filter by subgroup IDs (multiple values, UUIDs)"
// @Param			group_ids		query		[]string				false	"Filter by group IDs (multiple values, UUIDs)"
// @Param			names			query		[]string				false	"Filter by names (multiple values)"
// @Success		200				{object}	response.PaginationResponse{data=[]dto.RespTypeIndex}	"Successfully retrieved types"
// @Failure		400				{object}	response.NonPaginationResponse	"Bad request - invalid query parameters"
// @Failure		401				{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403				{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Router			/v1/type [get]
func (h *TypeHandler) GetIndex(c echo.Context) error {
	// initialize context from echo
	ctx := c.Request().Context()

	pageRequest := c.Get("page_request").(*request.PageRequest)

	// validate filter req.
	// initialize filter
	filter := new(dto.ReqTypeIndexFilter)

	// Bind form-data to the DTO
	if err := c.Bind(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	// Validate the request if necessary
	if err := c.Validate(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	res, total, err := h.Usecase.GetIndex(ctx, *pageRequest, *filter)

	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	respType := []dto.RespTypeIndex{}

	for _, v := range res {
		respType = append(respType, dto.ToRespTypeIndex(v))
	}

	respPag := response.PaginationResponse{}
	respPag, err = respPag.SetResponse(respType, total, pageRequest.PerPage, pageRequest.Page)

	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	return c.JSON(http.StatusOK, respPag)
}

// GetByID godoc
// @Summary		Get type by ID
// @Description	Retrieve a single type by its UUID. The response includes subgroup_name to identify which sub-group this type belongs to. Only returns non-deleted types. Requires 'api.master-data.type.view' permission.
// @Tags			Jenis
// @Accept			json
// @Produce		json
// @Security		BearerAuth
// @Param			id		path	string	true	"Type UUID"
// @Success		200		{object}	response.NonPaginationResponse{data=dto.RespType}	"Successfully retrieved type with subgroup_name"
// @Failure		400		{object}	response.NonPaginationResponse	"Bad request - invalid UUID"
// @Failure		401		{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403		{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Failure		404		{object}	response.NonPaginationResponse	"Type not found"
// @Router			/v1/type/{id} [get]
func (h *TypeHandler) GetByID(c echo.Context) error {
	// initialize context from echo
	ctx := c.Request().Context()

	id := c.Param("id")
	res, err := h.Usecase.GetByID(ctx, id)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}
	resp := response.NonPaginationResponse{}
	resp, _ = resp.SetResponse(dto.ToRespType(*res))
	return c.JSON(http.StatusOK, resp)
}

// Export godoc
// @Summary		Export types to Excel
// @Description	Export types to Excel file (.xlsx) with optional search and filter. Same search and filter logic as index but without pagination. Supports multiple filter values for type_code, subgroup_id, and name. Requires 'api.master-data.type.export' permission.
// @Tags			Jenis
// @Accept			json
// @Produce		application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
// @Security		BearerAuth
// @Param			search			query		string					false	"Search keyword (searches in type_code and name)"
// @Param			type_codes		query		[]string				false	"Filter by type codes (multiple values)"
// @Param			subgroup_ids	query		[]string				false	"Filter by subgroup IDs (multiple values, UUIDs)"
// @Param			names			query		[]string				false	"Filter by names (multiple values)"
// @Success		200				{file}		binary	"Excel file (types.xlsx) with types data"
// @Failure		400				{object}	response.NonPaginationResponse	"Bad request - invalid query parameters"
// @Failure		401				{object}	response.NonPaginationResponse	"Unauthorized"
// @Failure		403				{object}	response.NonPaginationResponse	"Forbidden - insufficient permissions"
// @Router			/v1/type/export [get]
func (h *TypeHandler) Export(c echo.Context) error {
	// initialize context from echo
	ctx := c.Request().Context()

	// validate filter req.
	// initialize filter
	filter := new(dto.ReqTypeIndexFilter)

	// Bind form-data to the DTO
	if err := c.Bind(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	// Validate the request if necessary
	if err := c.Validate(filter); err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	excelBytes, err := h.Usecase.Export(ctx, *filter)
	if err != nil {
		return c.JSON(http.StatusBadRequest, response.SetErrorResponse(http.StatusBadRequest, err.Error()))
	}

	c.Response().Header().Set(echo.HeaderContentType, constants.ExcelContent)
	c.Response().Header().Set(constants.FieldContentDisposition, constants.ExcelContentDisposition("types.xlsx"))
	return c.Blob(http.StatusOK, constants.ExcelContent, excelBytes)
}
